{"ast":null,"code":"import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { generateContent } from './gemini';\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\nexport const findMatchingJobs = async (candidate, jobPostings) => {\n  const matches = [];\n  for (const jobPosting of jobPostings) {\n    if (jobPosting.status !== 'published') continue;\n    const match = await analyzeMatch(candidate, jobPosting);\n    if (match.score > 0) {\n      matches.push({\n        candidate,\n        jobPosting,\n        match\n      });\n    }\n  }\n\n  // Sort matches by score in descending order\n  matches.sort((a, b) => b.match.score - a.match.score);\n  return matches;\n};\nexport const findMatchingCandidates = async (jobPosting, candidates) => {\n  const matches = [];\n  for (const candidate of candidates) {\n    const match = await analyzeMatch(candidate, jobPosting);\n    if (match.score > 0) {\n      matches.push({\n        candidate,\n        jobPosting,\n        match\n      });\n    }\n  }\n\n  // Sort matches by score in descending order\n  matches.sort((a, b) => b.match.score - a.match.score);\n  return matches;\n};\nconst analyzeMatch = async (candidate, jobPosting) => {\n  const prompt = `Analyze the match between this candidate and job posting:\n\nCandidate:\nName: ${candidate.name}\nPosition: ${candidate.position}\nExperience: ${candidate.experience.map(exp => `${exp.position} at ${exp.company} (${exp.startDate} - ${exp.endDate})`).join(', ')}\nEducation: ${candidate.education.map(edu => `${edu.degree} in ${edu.field} from ${edu.institution}`).join(', ')}\nSkills: ${candidate.skills.join(', ')}\nLanguages: ${candidate.languages.join(', ')}\n\nJob Posting:\nTitle: ${jobPosting.title}\nDepartment: ${jobPosting.department}\nLocation: ${jobPosting.location}\nEmployment Type: ${jobPosting.employmentType}\nShift: ${jobPosting.shift}\nExperience Level: ${jobPosting.experience}\nStore Type: ${jobPosting.storeType}\nDescription: ${jobPosting.description}\nPhysical Requirements: ${jobPosting.physicalRequirements.join(', ')}\nBenefits: ${jobPosting.benefits.join(', ')}\n\nPlease analyze the match and provide:\n1. A match score (0-100) based on skills, experience, and qualifications\n2. A detailed analysis of why this score was given\n3. The candidate's key strengths for this role\n4. Any gaps or areas for improvement\n5. Specific recommendations for the candidate\n\nFormat the response as a JSON object with the following structure:\n{\n  \"score\": number,\n  \"explanation\": string,\n  \"strengths\": string[],\n  \"gaps\": string[],\n  \"recommendations\": string[]\n}`;\n  try {\n    const response = await generateContent(prompt);\n    const matchResult = JSON.parse(response);\n    return matchResult;\n  } catch (error) {\n    console.error('Error analyzing match:', error);\n    return {\n      score: 0,\n      explanation: 'Error analyzing match',\n      strengths: [],\n      gaps: [],\n      recommendations: []\n    };\n  }\n};\nexport async function matchCandidateWithJob(candidate, jobPosting) {\n  try {\n    const model = genAI.getGenerativeModel({\n      model: \"gemini-1.5-flash\"\n    });\n\n    // Prepare the prompt for the matching analysis\n    const prompt = `Analyze the compatibility between this candidate and job posting. \n    Provide a detailed analysis including:\n    1. Overall match score (0-100)\n    2. Explanation of the score\n    3. Key strengths that make this a good match\n    4. Potential gaps or areas for improvement\n    5. Recommendations for the candidate\n\n    Job Posting:\n    Title: ${jobPosting.title}\n    Department: ${jobPosting.department}\n    Location: ${jobPosting.location}\n    Employment Type: ${jobPosting.employmentType}\n    Shift: ${jobPosting.shift}\n    Experience Level: ${jobPosting.experience}\n    Store Type: ${jobPosting.storeType}\n    Physical Requirements: ${jobPosting.physicalRequirements.join(', ')}\n    Benefits: ${jobPosting.benefits.join(', ')}\n    Description: ${jobPosting.description}\n\n    Candidate Profile:\n    Name: ${candidate.name}\n    Position: ${candidate.position}\n    Experience: ${candidate.experience.map(exp => `${exp.position} at ${exp.company} (${exp.startDate} - ${exp.endDate})`).join('\\n')}\n    Education: ${candidate.education.map(edu => `${edu.degree} in ${edu.field} from ${edu.institution} (${edu.graduationDate})`).join('\\n')}\n    Skills: ${candidate.skills.join(', ')}\n    Languages: ${candidate.languages.join(', ')}\n    Certifications: ${candidate.certifications.join(', ')}\n    Current Status: ${candidate.status}\n    Current Match Score: ${candidate.matchScore}\n\n    Please provide the analysis in the following JSON format:\n    {\n      \"score\": number,\n      \"explanation\": string,\n      \"strengths\": string[],\n      \"gaps\": string[],\n      \"recommendations\": string[]\n    }`;\n\n    // Generate the analysis\n    const result = await model.generateContent(prompt);\n    const response = await result.response;\n    const text = response.text();\n\n    // Clean up the response by removing markdown formatting and any potential text before/after the JSON\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No valid JSON found in the response');\n    }\n    const cleanedJson = jsonMatch[0];\n    const matchResult = JSON.parse(cleanedJson);\n    return matchResult;\n  } catch (error) {\n    console.error('Error matching candidate with job:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["GoogleGenerativeAI","generateContent","genAI","process","env","REACT_APP_GEMINI_API_KEY","findMatchingJobs","candidate","jobPostings","matches","jobPosting","status","match","analyzeMatch","score","push","sort","a","b","findMatchingCandidates","candidates","prompt","name","position","experience","map","exp","company","startDate","endDate","join","education","edu","degree","field","institution","skills","languages","title","department","location","employmentType","shift","storeType","description","physicalRequirements","benefits","response","matchResult","JSON","parse","error","console","explanation","strengths","gaps","recommendations","matchCandidateWithJob","model","getGenerativeModel","graduationDate","certifications","matchScore","result","text","jsonMatch","Error","cleanedJson"],"sources":["/Users/vchartier/Projects/HRCursor/src/services/matchingEngine.ts"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { JobPosting, Candidate } from '../types';\nimport { generateContent } from './gemini';\n\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\n\ninterface MatchResult {\n  score: number;\n  explanation: string;\n  strengths: string[];\n  gaps: string[];\n  recommendations: string[];\n}\n\ninterface Match {\n  candidate: Candidate;\n  jobPosting: JobPosting;\n  match: MatchResult;\n}\n\nexport const findMatchingJobs = async (candidate: Candidate, jobPostings: JobPosting[]): Promise<Match[]> => {\n  const matches: Match[] = [];\n\n  for (const jobPosting of jobPostings) {\n    if (jobPosting.status !== 'published') continue;\n\n    const match = await analyzeMatch(candidate, jobPosting);\n    if (match.score > 0) {\n      matches.push({\n        candidate,\n        jobPosting,\n        match,\n      });\n    }\n  }\n\n  // Sort matches by score in descending order\n  matches.sort((a, b) => b.match.score - a.match.score);\n\n  return matches;\n};\n\nexport const findMatchingCandidates = async (jobPosting: JobPosting, candidates: Candidate[]): Promise<Match[]> => {\n  const matches: Match[] = [];\n\n  for (const candidate of candidates) {\n    const match = await analyzeMatch(candidate, jobPosting);\n    if (match.score > 0) {\n      matches.push({\n        candidate,\n        jobPosting,\n        match,\n      });\n    }\n  }\n\n  // Sort matches by score in descending order\n  matches.sort((a, b) => b.match.score - a.match.score);\n\n  return matches;\n};\n\nconst analyzeMatch = async (candidate: Candidate, jobPosting: JobPosting): Promise<MatchResult> => {\n  const prompt = `Analyze the match between this candidate and job posting:\n\nCandidate:\nName: ${candidate.name}\nPosition: ${candidate.position}\nExperience: ${candidate.experience.map(exp => `${exp.position} at ${exp.company} (${exp.startDate} - ${exp.endDate})`).join(', ')}\nEducation: ${candidate.education.map(edu => `${edu.degree} in ${edu.field} from ${edu.institution}`).join(', ')}\nSkills: ${candidate.skills.join(', ')}\nLanguages: ${candidate.languages.join(', ')}\n\nJob Posting:\nTitle: ${jobPosting.title}\nDepartment: ${jobPosting.department}\nLocation: ${jobPosting.location}\nEmployment Type: ${jobPosting.employmentType}\nShift: ${jobPosting.shift}\nExperience Level: ${jobPosting.experience}\nStore Type: ${jobPosting.storeType}\nDescription: ${jobPosting.description}\nPhysical Requirements: ${jobPosting.physicalRequirements.join(', ')}\nBenefits: ${jobPosting.benefits.join(', ')}\n\nPlease analyze the match and provide:\n1. A match score (0-100) based on skills, experience, and qualifications\n2. A detailed analysis of why this score was given\n3. The candidate's key strengths for this role\n4. Any gaps or areas for improvement\n5. Specific recommendations for the candidate\n\nFormat the response as a JSON object with the following structure:\n{\n  \"score\": number,\n  \"explanation\": string,\n  \"strengths\": string[],\n  \"gaps\": string[],\n  \"recommendations\": string[]\n}`;\n\n  try {\n    const response = await generateContent(prompt);\n    const matchResult = JSON.parse(response);\n    return matchResult;\n  } catch (error) {\n    console.error('Error analyzing match:', error);\n    return {\n      score: 0,\n      explanation: 'Error analyzing match',\n      strengths: [],\n      gaps: [],\n      recommendations: [],\n    };\n  }\n};\n\nexport async function matchCandidateWithJob(\n  candidate: Candidate,\n  jobPosting: JobPosting\n): Promise<MatchResult> {\n  try {\n    const model = genAI.getGenerativeModel({ model: \"gemini-1.5-flash\" });\n\n    // Prepare the prompt for the matching analysis\n    const prompt = `Analyze the compatibility between this candidate and job posting. \n    Provide a detailed analysis including:\n    1. Overall match score (0-100)\n    2. Explanation of the score\n    3. Key strengths that make this a good match\n    4. Potential gaps or areas for improvement\n    5. Recommendations for the candidate\n\n    Job Posting:\n    Title: ${jobPosting.title}\n    Department: ${jobPosting.department}\n    Location: ${jobPosting.location}\n    Employment Type: ${jobPosting.employmentType}\n    Shift: ${jobPosting.shift}\n    Experience Level: ${jobPosting.experience}\n    Store Type: ${jobPosting.storeType}\n    Physical Requirements: ${jobPosting.physicalRequirements.join(', ')}\n    Benefits: ${jobPosting.benefits.join(', ')}\n    Description: ${jobPosting.description}\n\n    Candidate Profile:\n    Name: ${candidate.name}\n    Position: ${candidate.position}\n    Experience: ${candidate.experience.map(exp => \n      `${exp.position} at ${exp.company} (${exp.startDate} - ${exp.endDate})`\n    ).join('\\n')}\n    Education: ${candidate.education.map(edu => \n      `${edu.degree} in ${edu.field} from ${edu.institution} (${edu.graduationDate})`\n    ).join('\\n')}\n    Skills: ${candidate.skills.join(', ')}\n    Languages: ${candidate.languages.join(', ')}\n    Certifications: ${candidate.certifications.join(', ')}\n    Current Status: ${candidate.status}\n    Current Match Score: ${candidate.matchScore}\n\n    Please provide the analysis in the following JSON format:\n    {\n      \"score\": number,\n      \"explanation\": string,\n      \"strengths\": string[],\n      \"gaps\": string[],\n      \"recommendations\": string[]\n    }`;\n\n    // Generate the analysis\n    const result = await model.generateContent(prompt);\n    const response = await result.response;\n    const text = response.text();\n    \n    // Clean up the response by removing markdown formatting and any potential text before/after the JSON\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No valid JSON found in the response');\n    }\n    \n    const cleanedJson = jsonMatch[0];\n    const matchResult = JSON.parse(cleanedJson);\n\n    return matchResult;\n  } catch (error) {\n    console.error('Error matching candidate with job:', error);\n    throw error;\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}