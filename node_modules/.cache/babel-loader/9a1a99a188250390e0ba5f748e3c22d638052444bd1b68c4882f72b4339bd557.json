{"ast":null,"code":"import { GoogleGenerativeAI } from '@google/generative-ai';\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\nexport const findMatchingJobs = async (candidate, jobPostings) => {\n  const matches = [];\n  for (const jobPosting of jobPostings) {\n    if (jobPosting.status !== 'published') continue;\n    const match = await analyzeMatch(candidate, jobPosting);\n    if (match.score > 0) {\n      matches.push({\n        candidate,\n        jobPosting,\n        match\n      });\n    }\n  }\n\n  // Sort matches by score in descending order\n  matches.sort((a, b) => b.match.score - a.match.score);\n  return matches;\n};\nexport const findMatchingCandidates = async (jobPosting, candidates) => {\n  const matches = [];\n  for (const candidate of candidates) {\n    const match = await analyzeMatch(candidate, jobPosting);\n    if (match.score > 0) {\n      matches.push({\n        candidate,\n        jobPosting,\n        match\n      });\n    }\n  }\n\n  // Sort matches by score in descending order\n  matches.sort((a, b) => b.match.score - a.match.score);\n  return matches;\n};\nconst analyzeMatch = async (candidate, jobPosting) => {\n  try {\n    const model = genAI.getGenerativeModel({\n      model: \"gemini-1.5-flash\"\n    });\n    const prompt = `Analyze the compatibility between this candidate and job posting. \n    Provide a detailed analysis including:\n    1. Overall match score (0-100)\n    2. Explanation of the score\n    3. Key strengths that make this a good match\n    4. Potential gaps or areas for improvement\n    5. Recommendations for the candidate\n\n    Job Posting:\n    Title: ${jobPosting.title}\n    Department: ${jobPosting.department}\n    Location: ${jobPosting.location}\n    Employment Type: ${jobPosting.employmentType}\n    Shift: ${jobPosting.shift}\n    Experience Level: ${jobPosting.experience}\n    Store Type: ${jobPosting.storeType}\n    Physical Requirements: ${jobPosting.physicalRequirements.join(', ')}\n    Benefits: ${jobPosting.benefits.join(', ')}\n    Description: ${jobPosting.description}\n\n    Candidate Profile:\n    Name: ${candidate.name}\n    Position: ${candidate.position}\n    Location: ${candidate.location}\n    Experience: ${candidate.experience.map(exp => `${exp.position} at ${exp.company} (${exp.startDate} - ${exp.endDate}): ${exp.description}`).join('\\n')}\n    Education: ${candidate.education.map(edu => `${edu.degree} in ${edu.field} from ${edu.institution} (${edu.graduationDate})`).join('\\n')}\n    Skills: ${candidate.skills.join(', ')}\n    Languages: ${candidate.languages.join(', ')}\n    Certifications: ${candidate.certifications.join(', ')}\n\n    Please provide the analysis in the following JSON format:\n    {\n      \"score\": number,\n      \"explanation\": string,\n      \"strengths\": string[],\n      \"gaps\": string[],\n      \"recommendations\": string[]\n    }\n\n    Consider factors like:\n    - Location match and relocation requirements\n    - Language requirements\n    - Experience level match\n    - Skills alignment\n    - Education relevance\n    - Industry experience`;\n\n    // Generate the analysis\n    const result = await model.generateContent(prompt);\n    const response = await result.response;\n    const text = response.text();\n\n    // Clean up the response by removing markdown formatting and any potential text before/after the JSON\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No valid JSON found in the response');\n    }\n    const cleanedJson = jsonMatch[0];\n    const matchResult = JSON.parse(cleanedJson);\n    return matchResult;\n  } catch (error) {\n    console.error('Error analyzing match:', error);\n    return {\n      score: 0,\n      explanation: 'Error analyzing match. Please try again.',\n      strengths: [],\n      gaps: [],\n      recommendations: []\n    };\n  }\n};\nexport async function matchCandidateWithJob(candidate, jobPosting) {\n  try {\n    const model = genAI.getGenerativeModel({\n      model: \"gemini-1.5-flash\"\n    });\n\n    // Prepare the prompt for the matching analysis\n    const prompt = `Analyze the compatibility between this candidate and job posting. \n    Provide a detailed analysis including:\n    1. Overall match score (0-100)\n    2. Explanation of the score\n    3. Key strengths that make this a good match\n    4. Potential gaps or areas for improvement\n    5. Recommendations for the candidate\n\n    Job Posting:\n    Title: ${jobPosting.title}\n    Department: ${jobPosting.department}\n    Location: ${jobPosting.location}\n    Employment Type: ${jobPosting.employmentType}\n    Shift: ${jobPosting.shift}\n    Experience Level: ${jobPosting.experience}\n    Store Type: ${jobPosting.storeType}\n    Physical Requirements: ${jobPosting.physicalRequirements.join(', ')}\n    Benefits: ${jobPosting.benefits.join(', ')}\n    Description: ${jobPosting.description}\n\n    Candidate Profile:\n    Name: ${candidate.name}\n    Position: ${candidate.position}\n    Experience: ${candidate.experience.map(exp => `${exp.position} at ${exp.company} (${exp.startDate} - ${exp.endDate})`).join('\\n')}\n    Education: ${candidate.education.map(edu => `${edu.degree} in ${edu.field} from ${edu.institution} (${edu.graduationDate})`).join('\\n')}\n    Skills: ${candidate.skills.join(', ')}\n    Languages: ${candidate.languages.join(', ')}\n    Certifications: ${candidate.certifications.join(', ')}\n    Current Status: ${candidate.status}\n    Current Match Score: ${candidate.matchScore}\n\n    Please provide the analysis in the following JSON format:\n    {\n      \"score\": number,\n      \"explanation\": string,\n      \"strengths\": string[],\n      \"gaps\": string[],\n      \"recommendations\": string[]\n    }`;\n\n    // Generate the analysis\n    const result = await model.generateContent(prompt);\n    const response = await result.response;\n    const text = response.text();\n\n    // Clean up the response by removing markdown formatting and any potential text before/after the JSON\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No valid JSON found in the response');\n    }\n    const cleanedJson = jsonMatch[0];\n    const matchResult = JSON.parse(cleanedJson);\n    return matchResult;\n  } catch (error) {\n    console.error('Error matching candidate with job:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["GoogleGenerativeAI","genAI","process","env","REACT_APP_GEMINI_API_KEY","findMatchingJobs","candidate","jobPostings","matches","jobPosting","status","match","analyzeMatch","score","push","sort","a","b","findMatchingCandidates","candidates","model","getGenerativeModel","prompt","title","department","location","employmentType","shift","experience","storeType","physicalRequirements","join","benefits","description","name","position","map","exp","company","startDate","endDate","education","edu","degree","field","institution","graduationDate","skills","languages","certifications","result","generateContent","response","text","jsonMatch","Error","cleanedJson","matchResult","JSON","parse","error","console","explanation","strengths","gaps","recommendations","matchCandidateWithJob","matchScore"],"sources":["/Users/vchartier/Projects/HRCursor/src/services/matchingEngine.ts"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { JobPosting, Candidate } from '../types';\n\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\n\ninterface MatchResult {\n  score: number;\n  explanation: string;\n  strengths: string[];\n  gaps: string[];\n  recommendations: string[];\n}\n\ninterface Match {\n  candidate: Candidate;\n  jobPosting: JobPosting;\n  match: MatchResult;\n}\n\nexport const findMatchingJobs = async (candidate: Candidate, jobPostings: JobPosting[]): Promise<Match[]> => {\n  const matches: Match[] = [];\n\n  for (const jobPosting of jobPostings) {\n    if (jobPosting.status !== 'published') continue;\n\n    const match = await analyzeMatch(candidate, jobPosting);\n    if (match.score > 0) {\n      matches.push({\n        candidate,\n        jobPosting,\n        match,\n      });\n    }\n  }\n\n  // Sort matches by score in descending order\n  matches.sort((a, b) => b.match.score - a.match.score);\n\n  return matches;\n};\n\nexport const findMatchingCandidates = async (jobPosting: JobPosting, candidates: Candidate[]): Promise<Match[]> => {\n  const matches: Match[] = [];\n\n  for (const candidate of candidates) {\n    const match = await analyzeMatch(candidate, jobPosting);\n    if (match.score > 0) {\n      matches.push({\n        candidate,\n        jobPosting,\n        match,\n      });\n    }\n  }\n\n  // Sort matches by score in descending order\n  matches.sort((a, b) => b.match.score - a.match.score);\n\n  return matches;\n};\n\nconst analyzeMatch = async (candidate: Candidate, jobPosting: JobPosting): Promise<MatchResult> => {\n  try {\n    const model = genAI.getGenerativeModel({ model: \"gemini-1.5-flash\" });\n\n    const prompt = `Analyze the compatibility between this candidate and job posting. \n    Provide a detailed analysis including:\n    1. Overall match score (0-100)\n    2. Explanation of the score\n    3. Key strengths that make this a good match\n    4. Potential gaps or areas for improvement\n    5. Recommendations for the candidate\n\n    Job Posting:\n    Title: ${jobPosting.title}\n    Department: ${jobPosting.department}\n    Location: ${jobPosting.location}\n    Employment Type: ${jobPosting.employmentType}\n    Shift: ${jobPosting.shift}\n    Experience Level: ${jobPosting.experience}\n    Store Type: ${jobPosting.storeType}\n    Physical Requirements: ${jobPosting.physicalRequirements.join(', ')}\n    Benefits: ${jobPosting.benefits.join(', ')}\n    Description: ${jobPosting.description}\n\n    Candidate Profile:\n    Name: ${candidate.name}\n    Position: ${candidate.position}\n    Location: ${candidate.location}\n    Experience: ${candidate.experience.map(exp => \n      `${exp.position} at ${exp.company} (${exp.startDate} - ${exp.endDate}): ${exp.description}`\n    ).join('\\n')}\n    Education: ${candidate.education.map(edu => \n      `${edu.degree} in ${edu.field} from ${edu.institution} (${edu.graduationDate})`\n    ).join('\\n')}\n    Skills: ${candidate.skills.join(', ')}\n    Languages: ${candidate.languages.join(', ')}\n    Certifications: ${candidate.certifications.join(', ')}\n\n    Please provide the analysis in the following JSON format:\n    {\n      \"score\": number,\n      \"explanation\": string,\n      \"strengths\": string[],\n      \"gaps\": string[],\n      \"recommendations\": string[]\n    }\n\n    Consider factors like:\n    - Location match and relocation requirements\n    - Language requirements\n    - Experience level match\n    - Skills alignment\n    - Education relevance\n    - Industry experience`;\n\n    // Generate the analysis\n    const result = await model.generateContent(prompt);\n    const response = await result.response;\n    const text = response.text();\n    \n    // Clean up the response by removing markdown formatting and any potential text before/after the JSON\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No valid JSON found in the response');\n    }\n    \n    const cleanedJson = jsonMatch[0];\n    const matchResult = JSON.parse(cleanedJson);\n\n    return matchResult;\n  } catch (error) {\n    console.error('Error analyzing match:', error);\n    return {\n      score: 0,\n      explanation: 'Error analyzing match. Please try again.',\n      strengths: [],\n      gaps: [],\n      recommendations: [],\n    };\n  }\n};\n\nexport async function matchCandidateWithJob(\n  candidate: Candidate,\n  jobPosting: JobPosting\n): Promise<MatchResult> {\n  try {\n    const model = genAI.getGenerativeModel({ model: \"gemini-1.5-flash\" });\n\n    // Prepare the prompt for the matching analysis\n    const prompt = `Analyze the compatibility between this candidate and job posting. \n    Provide a detailed analysis including:\n    1. Overall match score (0-100)\n    2. Explanation of the score\n    3. Key strengths that make this a good match\n    4. Potential gaps or areas for improvement\n    5. Recommendations for the candidate\n\n    Job Posting:\n    Title: ${jobPosting.title}\n    Department: ${jobPosting.department}\n    Location: ${jobPosting.location}\n    Employment Type: ${jobPosting.employmentType}\n    Shift: ${jobPosting.shift}\n    Experience Level: ${jobPosting.experience}\n    Store Type: ${jobPosting.storeType}\n    Physical Requirements: ${jobPosting.physicalRequirements.join(', ')}\n    Benefits: ${jobPosting.benefits.join(', ')}\n    Description: ${jobPosting.description}\n\n    Candidate Profile:\n    Name: ${candidate.name}\n    Position: ${candidate.position}\n    Experience: ${candidate.experience.map(exp => \n      `${exp.position} at ${exp.company} (${exp.startDate} - ${exp.endDate})`\n    ).join('\\n')}\n    Education: ${candidate.education.map(edu => \n      `${edu.degree} in ${edu.field} from ${edu.institution} (${edu.graduationDate})`\n    ).join('\\n')}\n    Skills: ${candidate.skills.join(', ')}\n    Languages: ${candidate.languages.join(', ')}\n    Certifications: ${candidate.certifications.join(', ')}\n    Current Status: ${candidate.status}\n    Current Match Score: ${candidate.matchScore}\n\n    Please provide the analysis in the following JSON format:\n    {\n      \"score\": number,\n      \"explanation\": string,\n      \"strengths\": string[],\n      \"gaps\": string[],\n      \"recommendations\": string[]\n    }`;\n\n    // Generate the analysis\n    const result = await model.generateContent(prompt);\n    const response = await result.response;\n    const text = response.text();\n    \n    // Clean up the response by removing markdown formatting and any potential text before/after the JSON\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No valid JSON found in the response');\n    }\n    \n    const cleanedJson = jsonMatch[0];\n    const matchResult = JSON.parse(cleanedJson);\n\n    return matchResult;\n  } catch (error) {\n    console.error('Error matching candidate with job:', error);\n    throw error;\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}