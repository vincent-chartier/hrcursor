{"ast":null,"code":"import { generateContent } from './gemini';\nexport const generateInterviewQuestions = async (stage, jobPosting) => {\n  const prompt = `Generate exactly 5 interview questions for a ${stage.type} interview for a ${jobPosting.title} position.\n  \nJob details:\nTitle: ${jobPosting.title}\nDepartment: ${jobPosting.department}\nDescription: ${jobPosting.description}\nExperience Level: ${jobPosting.experience}\n\nFor each question, provide:\n1. The question text\n2. The type of question (technical, behavioral, or situational)\n3. What to look for in the answer\n4. The scoring criteria (what constitutes a good vs poor response)\n\nFormat each question as a JSON object with these exact fields:\n{\n  \"text\": \"question text here\",\n  \"type\": \"open_ended\",\n  \"category\": \"type of question\",\n  \"expectedAnswer\": \"what to look for in the answer\"\n}\n\nReturn exactly 5 questions in a JSON array.`;\n  const response = await generateContent(prompt);\n  try {\n    const questions = JSON.parse(response);\n    return questions.slice(0, 5).map(q => ({\n      text: q.text,\n      type: 'open_ended',\n      category: q.category,\n      expectedAnswer: q.expectedAnswer\n    }));\n  } catch (error) {\n    console.error('Error parsing Gemini response:', error);\n    // Fallback questions if parsing fails\n    return Array(5).fill(null).map((_, i) => ({\n      text: `Question ${i + 1} for ${stage.type} stage`,\n      type: 'open_ended',\n      category: stage.type,\n      expectedAnswer: 'Looking for clear, structured responses demonstrating relevant experience and knowledge'\n    }));\n  }\n};\nexport const analyzeAnswer = async (question, answer) => {\n  const prompt = `Analyze the following interview answer for the question: \"${question.text}\"\n\nExpected answer criteria:\n${question.expectedAnswer}\n\nCandidate's answer:\n${answer}\n\nPlease provide:\n1. A score from 0-100\n2. Specific feedback on the answer's strengths and areas for improvement`;\n  const response = await generateContent(prompt);\n  const scoreMatch = response.match(/score:\\s*(\\d+)/i);\n  const feedbackMatch = response.match(/feedback:([\\s\\S]*?)(?=\\n\\n|$)/i);\n  return {\n    score: scoreMatch ? parseInt(scoreMatch[1], 10) : 50,\n    feedback: feedbackMatch ? feedbackMatch[1].trim() : 'No specific feedback provided'\n  };\n};\nexport const generateStageFeedback = async (questions, stage) => {\n  const prompt = `Analyze the following interview responses for a ${stage.type} interview:\n\n${questions.map(q => `\nQuestion: ${q.text}\nAnswer: ${q.actualAnswer}\nScore: ${q.score}\nIndividual Feedback: ${q.feedback}\n`).join('\\n')}\n\nPlease provide:\n1. An overall assessment score (0-100)\n2. A summary of the candidate's performance\n3. Recommended next steps`;\n  const response = await generateContent(prompt);\n  const scoreMatch = response.match(/overall score:\\s*(\\d+)/i);\n  const feedbackMatch = response.match(/summary:([\\s\\S]*?)(?=next steps:|$)/i);\n  const nextStepsMatch = response.match(/next steps:([\\s\\S]*?)$/i);\n  const averageScore = questions.reduce((sum, q) => sum + (q.score || 0), 0) / questions.length;\n  return {\n    overallScore: scoreMatch ? parseInt(scoreMatch[1], 10) : Math.round(averageScore),\n    feedback: feedbackMatch ? feedbackMatch[1].trim() : 'No overall feedback provided',\n    nextSteps: nextStepsMatch ? nextStepsMatch[1].trim() : 'No next steps provided'\n  };\n};","map":{"version":3,"names":["generateContent","generateInterviewQuestions","stage","jobPosting","prompt","type","title","department","description","experience","response","questions","JSON","parse","slice","map","q","text","category","expectedAnswer","error","console","Array","fill","_","i","analyzeAnswer","question","answer","scoreMatch","match","feedbackMatch","score","parseInt","feedback","trim","generateStageFeedback","actualAnswer","join","nextStepsMatch","averageScore","reduce","sum","length","overallScore","Math","round","nextSteps"],"sources":["/Users/vchartier/Projects/HRCursor/src/services/interview.ts"],"sourcesContent":["import { generateContent } from './gemini';\nimport { InterviewStage, JobPosting, InterviewQuestion, InterviewFeedback } from '../types';\n\nexport const generateInterviewQuestions = async (\n  stage: InterviewStage,\n  jobPosting: JobPosting\n): Promise<InterviewQuestion[]> => {\n  const prompt = `Generate exactly 5 interview questions for a ${stage.type} interview for a ${jobPosting.title} position.\n  \nJob details:\nTitle: ${jobPosting.title}\nDepartment: ${jobPosting.department}\nDescription: ${jobPosting.description}\nExperience Level: ${jobPosting.experience}\n\nFor each question, provide:\n1. The question text\n2. The type of question (technical, behavioral, or situational)\n3. What to look for in the answer\n4. The scoring criteria (what constitutes a good vs poor response)\n\nFormat each question as a JSON object with these exact fields:\n{\n  \"text\": \"question text here\",\n  \"type\": \"open_ended\",\n  \"category\": \"type of question\",\n  \"expectedAnswer\": \"what to look for in the answer\"\n}\n\nReturn exactly 5 questions in a JSON array.`;\n\n  const response = await generateContent(prompt);\n  \n  try {\n    const questions = JSON.parse(response);\n    return questions.slice(0, 5).map((q: any) => ({\n      text: q.text,\n      type: 'open_ended' as const,\n      category: q.category,\n      expectedAnswer: q.expectedAnswer\n    }));\n  } catch (error) {\n    console.error('Error parsing Gemini response:', error);\n    // Fallback questions if parsing fails\n    return Array(5).fill(null).map((_, i) => ({\n      text: `Question ${i + 1} for ${stage.type} stage`,\n      type: 'open_ended' as const,\n      category: stage.type,\n      expectedAnswer: 'Looking for clear, structured responses demonstrating relevant experience and knowledge'\n    }));\n  }\n};\n\nexport const analyzeAnswer = async (\n  question: InterviewQuestion,\n  answer: string,\n): Promise<{ score: number; feedback: string }> => {\n  const prompt = `Analyze the following interview answer for the question: \"${question.text}\"\n\nExpected answer criteria:\n${question.expectedAnswer}\n\nCandidate's answer:\n${answer}\n\nPlease provide:\n1. A score from 0-100\n2. Specific feedback on the answer's strengths and areas for improvement`;\n\n  const response = await generateContent(prompt);\n  const scoreMatch = response.match(/score:\\s*(\\d+)/i);\n  const feedbackMatch = response.match(/feedback:([\\s\\S]*?)(?=\\n\\n|$)/i);\n\n  return {\n    score: scoreMatch ? parseInt(scoreMatch[1], 10) : 50,\n    feedback: feedbackMatch ? feedbackMatch[1].trim() : 'No specific feedback provided'\n  };\n};\n\nexport const generateStageFeedback = async (\n  questions: InterviewQuestion[],\n  stage: InterviewStage\n): Promise<InterviewFeedback> => {\n  const prompt = `Analyze the following interview responses for a ${stage.type} interview:\n\n${questions.map(q => `\nQuestion: ${q.text}\nAnswer: ${q.actualAnswer}\nScore: ${q.score}\nIndividual Feedback: ${q.feedback}\n`).join('\\n')}\n\nPlease provide:\n1. An overall assessment score (0-100)\n2. A summary of the candidate's performance\n3. Recommended next steps`;\n\n  const response = await generateContent(prompt);\n  const scoreMatch = response.match(/overall score:\\s*(\\d+)/i);\n  const feedbackMatch = response.match(/summary:([\\s\\S]*?)(?=next steps:|$)/i);\n  const nextStepsMatch = response.match(/next steps:([\\s\\S]*?)$/i);\n\n  const averageScore = questions.reduce((sum, q) => sum + (q.score || 0), 0) / questions.length;\n\n  return {\n    overallScore: scoreMatch ? parseInt(scoreMatch[1], 10) : Math.round(averageScore),\n    feedback: feedbackMatch ? feedbackMatch[1].trim() : 'No overall feedback provided',\n    nextSteps: nextStepsMatch ? nextStepsMatch[1].trim() : 'No next steps provided'\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}