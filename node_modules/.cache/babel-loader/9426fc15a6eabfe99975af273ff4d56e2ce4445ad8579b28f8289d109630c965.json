{"ast":null,"code":"import { GoogleGenerativeAI } from '@google/generative-ai';\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\nexport async function processCV(file) {\n  try {\n    var _extractedData$person, _extractedData$person2;\n    // Convert file to base64\n    const base64Data = await fileToBase64(file);\n\n    // Get the model\n    const model = genAI.getGenerativeModel({\n      model: \"gemini-1.5-flash\"\n    });\n\n    // Prepare the prompt\n    const prompt = `Analyze this CV and extract the following information in JSON format:\n    {\n      \"personalInfo\": {\n        \"name\": \"Full name\",\n        \"email\": \"Email address\",\n        \"phone\": \"Phone number (if available)\",\n        \"location\": \"Location/City (if available)\"\n      },\n      \"workExperience\": [\n        {\n          \"company\": \"Company name\",\n          \"position\": \"Job title\",\n          \"startDate\": \"Start date\",\n          \"endDate\": \"End date (or 'Present')\",\n          \"description\": \"Brief description of responsibilities\"\n        }\n      ],\n      \"education\": [\n        {\n          \"institution\": \"Institution name\",\n          \"degree\": \"Degree name\",\n          \"field\": \"Field of study\",\n          \"graduationDate\": \"Graduation date\"\n        }\n      ],\n      \"skills\": [\"List of technical and professional skills\"],\n      \"languages\": [\"List of languages\"],\n      \"certifications\": [\"List of certifications\"]\n    }\n\n    Please ensure:\n    1. The response is valid JSON without any markdown formatting\n    2. All dates are in a consistent format (e.g., YYYY-MM or YYYY)\n    3. Empty arrays are used when no information is found\n    4. Required fields (name, email) are never empty strings\n    5. Optional fields can be empty strings if not found`;\n\n    // Generate content\n    const result = await model.generateContent([prompt, {\n      inlineData: {\n        mimeType: file.type,\n        data: base64Data\n      }\n    }]);\n    const response = await result.response;\n    const text = response.text();\n\n    // Clean up the response by removing markdown formatting and any potential text before/after the JSON\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No valid JSON found in the response');\n    }\n    const cleanedJson = jsonMatch[0];\n    const extractedData = JSON.parse(cleanedJson);\n\n    // Validate required fields\n    if (!((_extractedData$person = extractedData.personalInfo) !== null && _extractedData$person !== void 0 && _extractedData$person.name) || !((_extractedData$person2 = extractedData.personalInfo) !== null && _extractedData$person2 !== void 0 && _extractedData$person2.email)) {\n      throw new Error('Required fields (name, email) are missing from the CV');\n    }\n    return extractedData;\n  } catch (error) {\n    console.error('Error processing CV:', error);\n    throw error;\n  }\n}\n\n// Helper function to convert File to base64\nconst fileToBase64 = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = () => {\n      const base64String = reader.result;\n      // Remove the data URL prefix (e.g., \"data:image/jpeg;base64,\")\n      const base64Data = base64String.split(',')[1];\n      resolve(base64Data);\n    };\n    reader.onerror = error => reject(error);\n  });\n};\n\n// Convert extracted data to Candidate type\nexport const convertToCandidate = extractedData => {\n  // Get the most recent position from work experience\n  const position = extractedData.workExperience.length > 0 ? extractedData.workExperience[0].position : 'Not Specified';\n\n  // Calculate a basic match score based on experience and education\n  const matchScore = Math.min(100, 50 +\n  // Base score\n  extractedData.workExperience.length * 5 +\n  // Points for each work experience\n  extractedData.education.length * 5 +\n  // Points for each education entry\n  extractedData.skills.length * 2 +\n  // Points for each skill\n  extractedData.languages.length * 3 // Points for each language\n  );\n  return {\n    name: extractedData.personalInfo.name || '',\n    email: extractedData.personalInfo.email || '',\n    phone: extractedData.personalInfo.phone || '',\n    location: extractedData.personalInfo.location || '',\n    position: position || 'Not Specified',\n    status: 'new',\n    matchScore,\n    experience: extractedData.workExperience.map(exp => ({\n      company: exp.company || '',\n      position: exp.position || '',\n      startDate: exp.startDate || '',\n      endDate: exp.endDate || 'Present',\n      description: exp.description || ''\n    })),\n    education: extractedData.education.map(edu => ({\n      institution: edu.institution || '',\n      degree: edu.degree || '',\n      field: edu.field || '',\n      graduationDate: edu.graduationDate || ''\n    })),\n    skills: extractedData.skills || [],\n    languages: extractedData.languages || [],\n    certifications: extractedData.certifications || [],\n    notes: '',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  };\n};","map":{"version":3,"names":["GoogleGenerativeAI","genAI","process","env","REACT_APP_GEMINI_API_KEY","processCV","file","_extractedData$person","_extractedData$person2","base64Data","fileToBase64","model","getGenerativeModel","prompt","result","generateContent","inlineData","mimeType","type","data","response","text","jsonMatch","match","Error","cleanedJson","extractedData","JSON","parse","personalInfo","name","email","error","console","Promise","resolve","reject","reader","FileReader","readAsDataURL","onload","base64String","split","onerror","convertToCandidate","position","workExperience","length","matchScore","Math","min","education","skills","languages","phone","location","status","experience","map","exp","company","startDate","endDate","description","edu","institution","degree","field","graduationDate","certifications","notes","createdAt","Date","toISOString","updatedAt"],"sources":["/Users/vchartier/Projects/HRCursor/src/services/cvProcessor.ts"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { Candidate } from '../types';\n\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\n\ninterface ExtractedCVData {\n  personalInfo: {\n    name: string;\n    email: string;\n    phone?: string;\n    location?: string;\n  };\n  workExperience: Array<{\n    company: string;\n    position: string;\n    startDate: string;\n    endDate?: string;\n    description: string;\n  }>;\n  education: Array<{\n    institution: string;\n    degree: string;\n    field: string;\n    graduationDate: string;\n  }>;\n  skills: string[];\n  languages: string[];\n  certifications: string[];\n}\n\nexport async function processCV(file: File): Promise<ExtractedCVData> {\n  try {\n    // Convert file to base64\n    const base64Data = await fileToBase64(file);\n\n    // Get the model\n    const model = genAI.getGenerativeModel({ model: \"gemini-1.5-flash\" });\n\n    // Prepare the prompt\n    const prompt = `Analyze this CV and extract the following information in JSON format:\n    {\n      \"personalInfo\": {\n        \"name\": \"Full name\",\n        \"email\": \"Email address\",\n        \"phone\": \"Phone number (if available)\",\n        \"location\": \"Location/City (if available)\"\n      },\n      \"workExperience\": [\n        {\n          \"company\": \"Company name\",\n          \"position\": \"Job title\",\n          \"startDate\": \"Start date\",\n          \"endDate\": \"End date (or 'Present')\",\n          \"description\": \"Brief description of responsibilities\"\n        }\n      ],\n      \"education\": [\n        {\n          \"institution\": \"Institution name\",\n          \"degree\": \"Degree name\",\n          \"field\": \"Field of study\",\n          \"graduationDate\": \"Graduation date\"\n        }\n      ],\n      \"skills\": [\"List of technical and professional skills\"],\n      \"languages\": [\"List of languages\"],\n      \"certifications\": [\"List of certifications\"]\n    }\n\n    Please ensure:\n    1. The response is valid JSON without any markdown formatting\n    2. All dates are in a consistent format (e.g., YYYY-MM or YYYY)\n    3. Empty arrays are used when no information is found\n    4. Required fields (name, email) are never empty strings\n    5. Optional fields can be empty strings if not found`;\n\n    // Generate content\n    const result = await model.generateContent([\n      prompt,\n      {\n        inlineData: {\n          mimeType: file.type,\n          data: base64Data\n        }\n      }\n    ]);\n\n    const response = await result.response;\n    const text = response.text();\n    \n    // Clean up the response by removing markdown formatting and any potential text before/after the JSON\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No valid JSON found in the response');\n    }\n    \n    const cleanedJson = jsonMatch[0];\n    const extractedData = JSON.parse(cleanedJson);\n\n    // Validate required fields\n    if (!extractedData.personalInfo?.name || !extractedData.personalInfo?.email) {\n      throw new Error('Required fields (name, email) are missing from the CV');\n    }\n\n    return extractedData;\n  } catch (error) {\n    console.error('Error processing CV:', error);\n    throw error;\n  }\n}\n\n// Helper function to convert File to base64\nconst fileToBase64 = (file: File): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = () => {\n      const base64String = reader.result as string;\n      // Remove the data URL prefix (e.g., \"data:image/jpeg;base64,\")\n      const base64Data = base64String.split(',')[1];\n      resolve(base64Data);\n    };\n    reader.onerror = error => reject(error);\n  });\n};\n\n// Convert extracted data to Candidate type\nexport const convertToCandidate = (extractedData: ExtractedCVData): Omit<Candidate, 'id'> => {\n  // Get the most recent position from work experience\n  const position = extractedData.workExperience.length > 0\n    ? extractedData.workExperience[0].position\n    : 'Not Specified';\n\n  // Calculate a basic match score based on experience and education\n  const matchScore = Math.min(\n    100,\n    50 + // Base score\n    (extractedData.workExperience.length * 5) + // Points for each work experience\n    (extractedData.education.length * 5) + // Points for each education entry\n    (extractedData.skills.length * 2) + // Points for each skill\n    (extractedData.languages.length * 3) // Points for each language\n  );\n\n  return {\n    name: extractedData.personalInfo.name || '',\n    email: extractedData.personalInfo.email || '',\n    phone: extractedData.personalInfo.phone || '',\n    location: extractedData.personalInfo.location || '',\n    position: position || 'Not Specified',\n    status: 'new',\n    matchScore,\n    experience: extractedData.workExperience.map(exp => ({\n      company: exp.company || '',\n      position: exp.position || '',\n      startDate: exp.startDate || '',\n      endDate: exp.endDate || 'Present',\n      description: exp.description || ''\n    })),\n    education: extractedData.education.map(edu => ({\n      institution: edu.institution || '',\n      degree: edu.degree || '',\n      field: edu.field || '',\n      graduationDate: edu.graduationDate || ''\n    })),\n    skills: extractedData.skills || [],\n    languages: extractedData.languages || [],\n    certifications: extractedData.certifications || [],\n    notes: '',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}